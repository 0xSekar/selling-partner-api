<?php declare(strict_types=1);
/**
 * Configuration
 * PHP version 8.1
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   Jesse Evers
 * @email    jesse@highsidelabs.co
 */

{{>partials/partial_header}}

namespace {{invokerPackage}};

use DateTime;
use InvalidArgumentException;
use RuntimeException;

class Configuration
{
    /**
     * Associative array to store API key(s) by scheme name
     *
     * @var string[]
     */
    protected array $apiKeys = [];

    /**
     * A map of client IDs to access tokens.
     *
     * @var array[string => SellingPartnerApi\AccessToken]
     */
    private static array $accessTokens = [];

    /**
     * Client ID for HTTP basic authentication
     *
     * @var string
     */
    protected string $clientId;

    /**
     * Client secret for HTTP basic authentication
     *
     * @var string
     */
    protected string $clientSecret;

    /**
     * The host
     *
     * @var string
     */
    protected string $host = '{{basePath}}';

    /**
     * User agent of the HTTP request
     *
     * @var string
     */
    protected string $userAgent = '{{{httpUserAgent}}}';

    /**
     * Debug switch (default set to false)
     *
     * @var bool
     */
    protected bool $debug = false;

    /**
     * Debug file location (log to STDOUT by default)
     *
     * @var string
     */
    protected string $debugFile = 'php://output';

    /**
     * Temporary folder
     *
     * @var string
     */
    protected static ?string $tempFolderPath = null;

    /**
     * Constructor
     */
    public function __construct(array $options = [])
    {
        $this->validateOptions($options);
    }

    /**
     * Sets API key by auth scheme name
     *
     * @param string $apiKeyIdentifier API key identifier (authentication scheme name)
     * @param string $key              API key or token
     *
     * @return $this
     */
    public function setApiKey(string $apiKeyIdentifier, string $key): static
    {
        $method = 'set' . ucfirst($apiKeyIdentifier);
        if (!method_exists(static::class, $method)) {
            throw new InvalidArgumentException("Invalid API key identifier: $apiKeyIdentifier");
        }

        $this->{$method}($key);
        return $this;
    }

    /**
     * Gets API key by auth scheme name
     *
     * @param string $apiKeyIdentifier API key identifier (authentication scheme name)
     * @param array $requestInfo Request information to use when retrieving the API key. Includes the request path,
     *                           HTTP method, millisecond timestamp, and query string.
     *
     * @return null|string API key or token
     */
    public function getApiKey(string $apiKeyIdentifier, array $requestInfo): ?string
    {
        $method = 'get' . ucfirst($apiKeyIdentifier);
        if (!method_exists(static::class, $method)) {
            throw new InvalidArgumentException("Invalid API key identifier: $apiKeyIdentifier");
        }

        return $this->{$method}($requestInfo);
    }

    /**
     * Sets the access token for OAuth
     *
     * @param {{invokerPackage}}\AccessToken|null $accessToken Token for OAuth
     *
     * @return $this
     */
    public function setAccessToken(?AccessToken $accessToken): static
    {
        if (!($accessToken instanceof AccessToken)) {
            throw new InvalidArgumentException('Invalid access token: must be an instance of ' . AccessToken::class);
        }

        self::$accessTokens[$this->clientId] = $accessToken;
        return $this;
    }

    /**
     * Gets the access token for OAuth
     *
     * @return {{invokerPackage}}\AccessToken|null Access token for OAuth
     */
    public function getAccessToken(): ?AccessToken
    {
        if (!array_key_exists($this->clientId, self::$accessTokens) || self::$accessTokens[$this->clientId]->expired()) {
            $authApi = Walmart::marketplace($this)->auth();
            $authResponse = $authApi->tokenAPI('client_credentials');
            $accessToken = $authResponse->getAccessToken();

            self::$accessTokens[$this->clientId] = new AccessToken(
                $accessToken,
                new DateTime("+{$authResponse->getExpiresIn()} seconds")
            );
        }

        return self::$accessTokens[$this->clientId];
    }

    /**
     * Sets the Client ID for HTTP basic authentication
     *
     * @param string $clientId Client ID for HTTP basic authentication
     *
     * @return $this
     */
    public function setClientId(string $clientId): static
    {
        $this->clientId = $clientId;
        return $this;
    }

    /**
     * Gets the client ID for HTTP basic authentication
     *
     * @return string Client ID for HTTP basic authentication
     */
    public function getClientId(): string
    {
        return $this->clientId;
    }

    /**
     * Sets the client ID for HTTP basic authentication
     *
     * @param string $clientSecret Client secret for HTTP basic authentication
     *
     * @return $this
     */
    public function setClientSecret(string $clientSecret): static
    {
        $this->clientSecret = $clientSecret;
        return $this;
    }

    /**
     * Gets the client ID for HTTP basic authentication
     *
     * @return string Client secret for HTTP basic authentication
     */
    public function getClientSecret(): string
    {
        return $this->clientSecret;
    }

    /**
     * Sets the host
     *
     * @param string $host Host
     *
     * @return $this
     */
    public function setHost(string $host): static
    {
        $this->host = $host;
        return $this;
    }

    /**
     * Gets the host
     *
     * @return string Host
     */
    public function getHost(): string
    {
        return $this->host;
    }

    /**
     * Sets the user agent of the api client
     *
     * @param string $userAgent the user agent of the api client
     *
     * @throws \InvalidArgumentException
     * @return $this
     */
    public function setUserAgent(string $userAgent)
    {
        if (!is_string($userAgent)) {
            throw new InvalidArgumentException('User-agent must be a string.');
        }

        $this->userAgent = $userAgent;
        return $this;
    }

    /**
     * Gets the user agent of the api client
     *
     * @return string user agent
     */
    public function getUserAgent()
    {
        return $this->userAgent;
    }

    /**
     * Sets debug flag
     *
     * @param bool $debug Debug flag. Default true
     *
     * @return $this
     */
    public function setDebug(bool $debug = true): static
    {
        $this->debug = $debug;
        return $this;
    }

    /**
     * Gets the debug flag
     *
     * @return bool
     */
    public function getDebug(): bool
    {
        return $this->debug;
    }

    /**
     * Sets the debug file
     *
     * @param string $debugFile Debug file
     *
     * @return $this
     */
    public function setDebugFile(string $debugFile): static
    {
        $this->debugFile = $debugFile;
        return $this;
    }

    /**
     * Gets the debug file
     *
     * @return string
     */
    public function getDebugFile(): string
    {
        return $this->debugFile;
    }

    /**
     * Sets the temp folder path
     *
     * @param ?string $tempFolderPath Temp folder path
     * @return void
     */
    public static function setTempFolderPath(?string $tempFolderPath = null): void
    {
        if ($tempFolderPath === null) {
            static::$tempFolderPath = sys_get_temp_dir();
        } else {
            static::$tempFolderPath = $tempFolderPath;
        }
    }

    /**
     * Gets the temp folder path
     *
     * @return string Temp folder path
     */
    public static function getTempFolderPath()
    {
        if (isset(static::$tempFolderPath) || static::$tempFolderPath === null) {
            static::setTempFolderPath();
        }
        return static::$tempFolderPath;
    }

    /**
     * Validate the options passed to the constructor
     *
     * @param array $options Associative array of options
     * @throws InvalidArgumentException
     * @return void
     */
    protected function validateOptions(array $options): void
    {
        $validKeys = [
            'clientId', 'clientSecret', 'country', 'accessToken', 'privateKey', 'consumerId', 'channelType', 'partnerId'
        ];
        $invalid = array_diff(array_keys($options), $validKeys);

        if (count($invalid) > 0) {
            throw new InvalidArgumentException('Invalid configuration option(s) passed: ' . implode(', ', $invalid));
        }

        foreach ($validKeys as $key) {
            if (!isset($options[$key]) || $options[$key] === null) {
                continue;
            }
            $this->{'set' . ucfirst($key)}($options[$key]);
        }
    }
}
