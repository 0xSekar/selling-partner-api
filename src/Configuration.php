<?php declare(strict_types=1);
/**
 * Configuration
 * PHP version 8.1
 *
 * @category Class
 * @package  SellingPartnerApi
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SellingPartnerApi;

use DateTime;
use Exception;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Utils as GuzzleUtils;
use InvalidArgumentException;
use RuntimeException;
use SellingPartnerApi\Enums\Endpoint;
use SellingPartnerApi\Enums\GrantlessScope;

class Configuration
{
    /**
     * Amazon's Login With Amazon (LWA) authorization endpoint.
     */
    const LWA_AUTH_URL = 'https://api.amazon.com/auth/o2/token';

    /**
     * The LWA client ID.
     *
     * @var string
     */
    protected string $clientId;

    /**
     * The LWA client secret.
     *
     * @var string
     */
    protected string $clientSecret;

    /**
     * The LWA refresh token.
     *
     * @var string
     */
    protected string $refreshToken;

    /**
     * A map of LWA client IDs to access tokens. Used to cache access tokens
     * for multiple clients in a single spot.
     *
     * @var array[string => AccessToken]
     */
    private static array $accessTokens = [];

    /**
     * The SP API endpoint.
     *
     * @var Endpoint
     */
    protected Endpoint $endpoint;

    /**
     * The access token update callback, if any.
     * PHP does not support callable type hints on attributes, so this is untyped.
     *
     * @var callable|null
     */
    protected $onUpdateCredentials = null;

    /**
     * The authentication client, if any.
     *
     * @var GuzzleHttp\ClientInterface|null
     */
    protected ClientInterface|null $authenticationClient = null;

    /**
     * User agent of the HTTP request
     *
     * @var string
     */
    protected $userAgent = 'jlevers/selling-partner-api/5.9.0 (Language=PHP)';

    /**
     * Debug switch (default set to false)
     *
     * @var bool
     */
    protected $debug = false;

    /**
     * Debug file location (log to STDOUT by default)
     *
     * @var string
     */
    protected $debugFile = 'php://output';

    /**
     * Debug file location (log to STDOUT by default)
     *
     * @var string
     */
    protected static $tempFolderPath = null;

    /**
     * @param array  $options  Array of configuration options
     * @throws Exception
     */
    public function __construct(array $options)
    {
        $this->validateOptions($options);
    }

    /**
     * Get LWA client ID.
     *
     * @return string
     */
    public function getClientId(): ?string
    {
        return $this->clientId;
    }

    /**
     * Set LWA client ID.
     *
     * @param string  $clientId
     * @return static
     */
    public function setClientId(string $clientId): static
    {
        $this->clientId = $clientId;
        return $this;
    }

    /**
     * Get LWA client secret.
     *
     * @return string
     */
    public function getClientSecret(): ?string
    {
        return $this->clientSecret;
    }

    /**
     * Set LWA client secret.
     *
     * @param string  $clientSecret
     * @return static
     */
    public function setClientSecret(string $clientSecret): static
    {
        $this->clientSecret = $clientSecret;
        return $this;
    }

    /**
     * Get LWA refresh token.
     *
     * @return string
     */
    public function getRefreshToken(): ?string
    {
        return $this->refreshToken;
    }

    /**
     * Set LWA refresh token.
     *
     * @param string  $refreshToken
     * @return static
     */
    public function setRefreshToken(string $refreshToken): static
    {
        $this->refreshToken = $refreshToken;
        return $this;
    }

    /**
     * Sets the access token for OAuth
     *
     * @param AccessToken  $accessToken  Token for OAuth
     *
     * @return $this
     */
    public function setAccessToken(AccessToken $accessToken): static
    {
        static::$accessTokens[$this->clientId] = $accessToken;
        return $this;
    }

    /**
     * Gets the access token for OAuth
     *
     * @param GrantlessScope|null  $scope  The scope of the request, if it's grantless
     * @return AccessToken|null  Access token for OAuth
     */
    public function getAccessToken(GrantlessScope $scope = null): AccessToken|null
    {
        // We don't cache grantless access tokens, since they're used relatively rarely
        // and caching them adds complexity
        if ($scope || !array_key_exists($this->clientId, static::$accessTokens) || static::$accessTokens[$this->clientId]->expired()) {
            $jsonData = [
                'grant_type' => $scope ? 'client_credentials' : 'refresh_token',
                'client_id' => $this->clientId,
                'client_secret' => $this->clientSecret,
            ];

            // Only pass one of `scope` and `refresh_token`. For more info, see:
            // https://developer-docs.amazon.com/sp-api/docs/connecting-to-the-selling-partner-api#step-1-request-a-login-with-amazon-access-token
            if ($scope) {
                $jsonData['scope'] = $scope;
            } else {
                if ($this->refreshToken === null) {
                    throw new RuntimeException('Refresh token is required unless calling a grantless API endpoint.');
                }
                $jsonData['refresh_token'] = $this->refreshToken;
            }

            $lwaTokenRequest = new Request(
                'POST',
                static::LWA_AUTH_URL,
                ['Content-Type' => 'application/json'],
                GuzzleUtils::jsonEncode($jsonData)
            );
            $res = $this->authenticationClient->send($lwaTokenRequest);

            $body = json_decode(stream_get_contents($res->getBody()), true);
            $accessToken = new AccessToken(
                $body['access_token'],
                new DateTime("+{$body['expires_in']} seconds")
            );

            if ($scope) {
                // As mentioned above, we don't cache grantless access tokens
                return $accessToken;
            }

            static::$accessTokens[$this->clientId] = $accessToken;
        }

        return static::$accessTokens[$this->clientId];
    }

    /**
     * Get current SP API endpoint.
     *
     * @return Endpoint
     */
    public function getEndpoint(): Endpoint
    {
        return $this->endpoint;
    }

    /**
     * Set SP API endpoint.
     *
     * @param array  $endpoint
     * @throws RuntimeException
     * @return static
     */
    public function setEndpoint(Endpoint $endpoint): static
    {
        $this->endpoint = $endpoint;
        return $this;
    }

    /**
     * Get the access token update callback, if any.
     *
     * @return callable|null
     */
    public function getOnUpdateCredentials(): callable|null
    {
        return $this->onUpdateCredentials;
    }

    /**
     * Set the access token update callback, if any.
     *
     * @param callable|null  $onUpdateCredentials
     * @return static
     */
    public function setOnUpdateCredentials(callable|null $onUpdateCredentials): static
    {
        $this->onUpdateCredentials = $onUpdateCredentials;
        return $this;
    }

    /**
     * Get the authentication client, if any.
     *
     * @return GuzzleHttp\ClientInterface|null
     */
    public function getAuthenticationClient(): ClientInterface|null
    {
        return $this->authenticationClient;
    }

    /**
     * Set the authentication client, if any.
     *
     * @param GuzzleHttp\ClientInterface|null  $authenticationClient
     * @return static
     */
    public function setAuthenticationClient(ClientInterface|null $authenticationClient): static
    {
        $this->authenticationClient = $authenticationClient;
        return $this;
    }

    /**
     * Gets the user agent of the api client
     *
     * @return string
     */
    public function getUserAgent()
    {
        return $this->userAgent;
    }

    /**
     * Sets debug flag
     *
     * @param bool $debug Debug flag
     * @return $this
     */
    public function setDebug(bool $debug): static
    {
        $this->debug = $debug;
        return $this;
    }

    /**
     * Gets the debug flag
     *
     * @return bool
     */
    public function getDebug()
    {
        return $this->debug;
    }

    /**
     * Sets the debug file
     *
     * @param string  $debugFile  Debug file path
     * @return $this
     */
    public function setDebugFile(string $debugFile): static
    {
        $this->debugFile = $debugFile;
        return $this;
    }

    /**
     * Gets the debug file
     *
     * @return string
     */
    public function getDebugFile()
    {
        return $this->debugFile;
    }

    /**
     * Sets the temp folder path
     *
     * @param string|null $tempFolderPath Temp folder path
     * @return void
     */
    public static function setTempFolderPath(string $tempFolderPath = null): void
    {
        if ($tempFolderPath === null) {
            static::$tempFolderPath = sys_get_temp_dir();
        } else {
            static::$tempFolderPath = $tempFolderPath;
        }
    }

    /**
     * Gets the temp folder path
     *
     * @return string Temp folder path
     */
    public static function getTempFolderPath()
    {
        if (isset(static::$tempFolderPath) || static::$tempFolderPath === null) {
            static::setTempFolderPath();
        }
        return static::$tempFolderPath;
    }

    /**
     * Sign a request to the Selling Partner API using the AWS Signature V4 protocol.
     *
     * @param Request $request The request to sign
     * @param string $scope The scope of the request, if it's grantless
     *
     * @return Request The signed request
     */
    public function signRequest($request, $scope = null, $restrictedPath = null, $operation = null)
    {
        return $this->requestSigner->signRequest($request, $scope, $restrictedPath, $operation);
    }

    /**
     * Validate the options passed to the constructor.
     *
     * @param array  $options  Associative array of options
     * @throws InvalidArgumentException
     * @return void
     */
    protected function validateOptions(array $options): void
    {
        $requiredKeys = [
            'clientId', 'clientSecret', 'endpoint',
        ];
        $missing = array_diff($requiredKeys, array_keys($options));
        if (count($missing) > 0) {
            throw new InvalidArgumentException('Required configuration option(s) missing: ' . implode(', ', $missing));
        }

        $validKeys = [
            'clientId', 'clientSecret', 'endpoint', 'refreshToken', 'accessToken',
            'onUpdateCredentials', 'authenticationClient',
        ];
        $invalid = array_diff(array_keys($options), $validKeys);
        if (count($invalid) > 0) {
            throw new InvalidArgumentException('Invalid configuration option(s) passed: ' . implode(', ', $invalid));
        }

        if (!array_key_exists('authenticationClient', $options)) {
            $options['authenticationClient'] = new Client();
        }

        foreach ($options as $option => $value) {
            $this->{'set' . ucfirst($option)}($value);
        }
    }
}
